## 최단경로 알고리즘

#### Dijkstra

하나의 정점에서 나머지 정점으로 가는 최단경로를 구하는 문제

```java
**준비물**
- 각 정점까지의 거리를 저장할 int[] distance
- 각 노드를 방문했는지 검사하는 Boolean[] visited
- 시작점에서 각 정점까지 가중치를 저장하는 prioriy queue
- 각 정점에 연결된 간선을 저장할 ArrayList<Edge>[] a
```



- 우선순위큐와 함께 사용하는 것이 좋음
- 이차원배열로 할 경우 -> 메모리 낭비 심했음
- 큐에 검사해야 하는 정점의 정보를 가진 Vertex객체를 담고 while문을 돌아 계속 검사하는 방식



#### 벨만-포드 알고리즘

음수 가중치가 있는 그래프에서 모든 정점으로 가는 최단 거리를 찾아줌.

하나의 출발점에서 출발하여 모든 지점으로 가는 최단 거리를 알 수 있음.

(Dijkstra알고리즘은 음의 가중치를 허용하지 않음.)

- 다익스트라: 정점중심의 최단 경로
- 벨만 포드: Edge중심의 최단 경로
  - 따라서 정점의 갯수가 V개라고 할 때,  모든 Edge들을 V-1번 보면서 각 정점의 최단 거리를 찾음.
  - V-1인 이유: cycle이 생기지 않을 때의 최대 간선의 수.

** 방문 되지 않은 정점(값이 무한대)에서 출발하는 edge는 고려하지 않음.

- 벨만 포드 알고리즘에서 V-1번 edge들을 거치고 나면 최단 거리가 완성되는데, 한 번 더 돌리게 되면 음의 사이클이 있는 지 없는지 검증 가능함. 음의 사이클이란, 한 노드에서 시작해 한 노드로 끝나는 경로중에 경로의 가중치를 모두 합한 값이 음수가 되는 경로를 말함. 따라서 V-1번째 갱신 거리와 V번째 갱신 거리를 비교했을 때 값이 달라짐다면 음의 사이클이 있다고 판단할 수 있음.

```
- 시작점으로부터 모든 정점의 거리를 무한대로 초기화. 
  시작점의 거리는 0으로 초기화하고, 정점의 갯수만큼 distance[] 배열을 만든다.
- 최단거리를 계산한다: V-1번 만큼 반복한다.
	- distance[next] > distance[current] + 간선 가중치라면,
	뒤에식으로 가중치 갱신
- 음의 사이클이 존재확인(V번째에 최단이 찾아지면 그거는 음의 사이클 있는거)
```

